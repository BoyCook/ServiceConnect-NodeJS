<testsuite name="Mocha Tests" tests="75" failures="0" errors="0" skipped="0" timestamp="Mon, 20 Nov 2017 14:53:56 GMT" time="0.156">
<testcase classname="bus" name="Bus Constructor should create build config" time="0.006"/>
<testcase classname="bus" name="Bus init should create and connect to client" time="0.001"/>
<testcase classname="bus" name="Bus init should bind connected event" time="0"/>
<testcase classname="bus" name="Bus init should call callback argument on connected" time="0"/>
<testcase classname="bus" name="Bus init should bind error event" time="0.001"/>
<testcase classname="bus" name="Bus addHandler should create and connect to client" time="0"/>
<testcase classname="bus" name="Bus addHandler should call consumeType on client" time="0"/>
<testcase classname="bus" name="Bus addHandler should add the message type and callback to the handler map" time="0"/>
<testcase classname="bus" name="Bus addHandler * message type should not call consumeType on client" time="0.001"/>
<testcase classname="bus" name="Bus addHandler should add * message type and callback to the handler map" time="0"/>
<testcase classname="bus" name="Bus removeHandler should remove handler mapping from handler dictionary" time="0"/>
<testcase classname="bus" name="Bus removeHandler if all callbacks have been removed for a type then removeType should be called on client" time="0"/>
<testcase classname="bus" name="Bus removeHandler if all callbacks have not been removed for a message type then removeType should not be called on the client" time="0"/>
<testcase classname="bus" name="Bus isHandled should return true if message type is mapped to a callback" time="0"/>
<testcase classname="bus" name="Bus isHandled should return false if message type is not mapped to a callback" time="0.001"/>
<testcase classname="bus" name="Bus isHandled should return false if message type has 0 callbacks" time="0"/>
<testcase classname="bus" name="Bus send should send message to client" time="0"/>
<testcase classname="bus" name="Bus publish should publish message to client" time="0"/>
<testcase classname="bus" name="Bus sendRequest should send message to client" time="0"/>
<testcase classname="bus" name="Bus sendRequest should add request to callback dictionary" time="0.002"/>
<testcase classname="bus" name="Bus sendRequest expected replies should be equal to number of endpoints passed into sendRequest" time="0"/>
<testcase classname="bus" name="Bus publishRequest should publish message to client" time="0"/>
<testcase classname="bus" name="Bus publishRequest should add request configuration" time="0.001"/>
<testcase classname="bus" name="Bus publishRequest should remove request configuration after timeout" time="0"/>
<testcase classname="bus" name="Bus publishRequest should set expected replies" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should process the correct message handlers" time="0.002"/>
<testcase classname="bus" name="Bus _consumeMessage should process the correct message handlers after processing filters" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should not process any message handlers if before filters return false" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should not process any message handlers if before filters return a promise that resolves to false" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should not process any message handlers if before filter throws exception" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should not process any message handlers if before filter returns a promise that is rejected" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should process before and after filters in order" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should successfully resolve promise if there are no message handlers" time="0"/>
<testcase classname="bus" name="Bus _consumeMessage should successfully resolve promise after processing all message handlers" time="0"/>
<testcase classname="bus" name="Bus _consumeMessage should successfully resolve promise after processing handlers that return promises" time="0"/>
<testcase classname="bus" name="Bus _consumeMessage reply callback should send message to source address" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage should throw error if a handler throws an exception" time="0"/>
<testcase classname="bus" name="Bus _consumeMessage should throw error if a handler returns a rejected promise" time="0.001"/>
<testcase classname="bus" name="Bus _consumeMessage if a handler throws an exception the error callback method should be called" time="0.001"/>
<testcase classname="bus" name="Bus close should close the client" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client connect should connect to the amqp client" time="0.029"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client connect should call error callback if error occurs during connect" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client connect should create channel after connecting" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client connect should call error callback if error occurs during create channel" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client connect should create queues after creating channel" time="0.002"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should create the queues" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should bind the queue to the message types defined in the handlers configuration" time="0.002"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should configure retries" time="0.002"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should configure errors" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should configure auditing if enabled" time="0.002"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should not configure auditing if disabled" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should begin consuming messages" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _createQueues should trigger the connected callback function defined in the configuration" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client consumeType should create a exchange with the same name as the supplied type" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client consumeType should bind the queue to the new exchange" time="0.007"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client removeType should unbind the queue from the exchange with name equal to the supplied type name" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client send should send a message to the supplied endpoint" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client send should send the correct message headings" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client send should send a message to the supplied endpoints if an array of endpoints is passed" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client publish should publish the message" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client publish should publish the message with the correct headers" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client publish should assert that the exchange exists before publishing" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage should set the correct headings" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage should call the consumeMessageCallback function" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage if successful and auditing is enabled should send message to audit queue" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage if successful and auditing is disabled should not send message to audit queue" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage if consumeMessageCallback is not successful should send message to retry queue with retry count set to 1" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage if result is not successful and headers already contain RetryCount should increment RetryCount and assign to headers" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage if consumeMessageCallback is not successful and retry count has reached max should send message to error queue" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _processMessage if consumeMessageCallback is not successful and retry count has reached max should add Exception to headers" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _consumeMessage should throw exception if the typename is not in the headers" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _consumeMessage should ack message if exception is thrown" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client _consumeMessage should ack after processing the message if noAck is false" time="0"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client close should close the channel" time="0.001"/>
<testcase classname="rabbitMQ" name="RabbitMQ Client close should delete the retry queue if autoDelete is enabled" time="0"/>
</testsuite>
